\documentclass[12pt]{report}

% ===== Kódolás, nyelv =====
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[magyar,english]{babel}
\frenchspacing

% ===== Oldalbeállítás =====
\usepackage[margin=2cm, top=5cm, bottom=2.5cm, bindingoffset=0cm]{geometry}
\usepackage{graphicx}

% ===== Hivatkozások =====
\usepackage{hyperref}
\hypersetup{hidelinks}

% ===== Listings és színek =====
\usepackage{xcolor}
\usepackage{listings}
\usepackage{textcomp}

\renewcommand{\lstlistingname}{Programkód}

\definecolor{codebg}{rgb}{0.97,0.97,0.97}
\definecolor{codeborder}{rgb}{0.8,0.8,0.8}
\definecolor{codekeyword}{rgb}{0,0,0.7}
\definecolor{codestring}{rgb}{0.6,0,0}
\definecolor{codecomment}{rgb}{0,0.45,0}
\definecolor{codenum}{rgb}{0.5,0.5,0.5}

\lstdefinestyle{basestyle}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\footnotesize,
    numberstyle=\tiny\color{codenum},
    numbers=left,
    numbersep=8pt,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    showstringspaces=false,
    frame=single,
    framerule=0.3pt,
    rulecolor=\color{codeborder},
    captionpos=b,
    keepspaces=true,
}

\lstdefinelanguage{MyXML}{
    language=XML,
    morestring=[b]",
    morestring=[s][\color{codekeyword}]{<}{>},
    morecomment=[s][\color{codecomment}]{<!--}{-->},
    stringstyle=\color{codestring},
}

\lstdefinelanguage{MyJava}{
    language=Java,
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment},
    stringstyle=\color{codestring},
}

\lstset{style=basestyle}

% ===== Fejléc/lábléc =====
\usepackage{fancyhdr}
\fancypagestyle{plain}{
  \fancyhf{}
  \fancyhead[R]{\leftmark}
  \fancyhead[L]{\thepage}
  \fancyfoot[C]{Adatkezelés XML környezetben}
}

\begin{document}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\thepage}
\fancyfoot[C]{Adatkezelés XML környezetben}

\title{\Huge JEGYZŐKÖNYV \\[4pt] \LARGE Adatkezelés XML környezetben}
\author{\Large Féléves feladat: Sport Club}
\date{\vspace{250px}
  \begin{flushleft}
    Készítette: \textbf{Takács Ákos}\\
    Neptunkód: \textbf{VTJ4ES}\\
    Dátum: \textbf{2025. 12. 03.}
  \end{flushleft}
  \vspace{15px}
  \begin{center}
    \textbf{Miskolc, 2025}
  \end{center}}
\maketitle

\tableofcontents
\clearpage

\chapter{A feladat leírása}

A feladat egy sport club (sportegyesület) adatainak modellezése és XML alapú megvalósítása. 
A rendszerben megjelennek az egyesületi sportolók, az edzők, az edzéscsoportok, a sportlétesítmények, 
valamint a tagsági viszonyok és versenyek. A cél egy olyan XML alapú adatleírás kialakítása, 
amelyre XSD séma épül, és amely később Java DOM API segítségével olvasható, módosítható, 
lekérdezhető és fájlba kiírható.

A tervezés és a megvalósítás során az angol nyelvű elnevezéseket használtam (entitásnevek, elemek, attribútumok), 
mivel ez a gyakorlat elterjedt a szoftverfejlesztésben.

A végleges modellben az alábbi fő entitások jelentek meg:

\begin{itemize}
  \item \textbf{Athlete}: sportolók,
  \item \textbf{Membership}: tagságtípusok,
  \item \textbf{Coach}: edzők,
  \item \textbf{Location}: helyszínek,
  \item \textbf{TrainingGroup}: edzéscsoportok,
  \item \textbf{Competition}: versenyek.
\end{itemize}

A gyökérből kiinduló központi logikai entitás a \textbf{Sport\_Club\_VTJ4ES} dokumentum, amely tartalmazza a felsorolt entitások példányait, valamint a köztük lévő kapcsolat-elemeket (HasMembership, JoinGroup, LeadGroup, TakePlaceAt, CompeteIn).

\chapter{I. feladat – XML/XSD létrehozás}

\section[ER modell]{A feladat ER modellje}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.999\linewidth]{ERVTJ4ES.png}
  \caption{A sport club ER modellje}
\end{figure}

\section[XDM modell]{A feladat XDM modellje}

Az XDM modell kialakításakor az ER modellben definiált entitásokat és kapcsolatokat kellett átvezetni XML-re. 
Figyelembe vettem az \texttt{1:1}, \texttt{1:N} és \texttt{N:M} kapcsolatokat, valamint az entitások elsődleges kulcsait.

Az \texttt{1:N} kapcsolatoknál a szaggatott nyíl mindig a „több” oldalon lévő kulcshoz mutat. 
Például a \textbf{Location} és \textbf{TrainingGroup} közötti kapcsolat esetén a \texttt{groupRef} 
attribútum mutat vissza a csoport elsődleges kulcsára. Az \texttt{N:M} kapcsolatok (JoinGroup, CompeteIn) 
esetében külön XDM kapcsolat-elem jelenik meg, amely tartalmazza a saját azonosítóját és a hivatkozásokat 
mindkét fő entitásra.

Többértékű tulajdonságok (pl. \texttt{skills}, \texttt{benefits}, \texttt{equipment}, \texttt{specializations}) 
XML-ben belső, ismétlődő elemekkel jelennek meg. A XDM modell gyökéreleme: \textbf{Sport\_Club\_VTJ4ES}.

\begin{figure}[h]
  \centering
  \includegraphics[width=1.01\linewidth]{XDMVTJ4ES.png}
  \caption{A sport club XDM modellje}
\end{figure}

\section[Az XML dokumentum]{Az XML dokumentum tervezése és példák}

Az XML-dokumentum a sportegyesület XDM-modelljének megfelelően készült, ahol minden fő entitás 
(Athlete, Membership, Coach, Location, TrainingGroup, Competition) önálló XML-elemként jelenik meg, 
az azonosítók pedig attribútumként szerepelnek. Az összetett attribútumok (például név és elérhetőség) 
külön gyermekelemekben helyezkednek el, míg a többértékű tulajdonságok (skills, benefits, equipment, 
specializations) ismétlődő elemek formájában jelennek meg. A kapcsolatok külön kapcsolat-elemekkel 
kerülnek leírásra (HasMembership, JoinGroup, LeadGroup, TakePlaceAt, CompeteIn), amelyek az érintett 
entitások azonosítóira hivatkozó \texttt{Ref} attribútumokat tartalmaznak, így egyértelműen modellezik 
az 1--N és N--M kapcsolatokat is.

\subsection*{Példa egy entitás XML-leképezésére (Athlete)}

\begin{lstlisting}[language=MyXML, caption={Athlete entitás XML-részlete}]
<Athlete athleteID="1">
    <name>
        <first_name>Daniel</first_name>
        <last_name>Kiss</last_name>
    </name>
    <birth_date>2001-04-10</birth_date>
    <contacts>
        <e_mail>daniel.kiss@example.com</e_mail>
        <phone_number>+36-30-111-1111</phone_number>
    </contacts>
    <skills>speed</skills>
    <skills>endurance</skills>
    <skills>technique</skills>
</Athlete>
\end{lstlisting}

Az \texttt{Athlete} elem egy adatbázisbeli táblának felel meg, ahol az \texttt{athleteID} attribútum jelöli az elsődleges kulcsot. 
A név összetett attribútumként önálló \texttt{<name>} elemben szerepel, a keresztnév és vezetéknév külön gyermekelemekben. 
A többértékű \texttt{skills} attribútumot ismétlődő \texttt{<skills>} elemek reprezentálják, így egy sportolóhoz több készség is 
hozzárendelhető.

\subsection*{Példa 1--N kapcsolat XML-es ábrázolására (Athlete–Membership)}

\begin{lstlisting}[language=MyXML, caption={HasMembership kapcsolat (Athlete–Membership)}]
<HasMembership hasMembershipID="1" athleteRef="1" membershipRef="1" joinDate="2024-01-01"/>
<HasMembership hasMembershipID="2" athleteRef="2" membershipRef="1" joinDate="2023-09-15"/>
<HasMembership hasMembershipID="3" athleteRef="3" membershipRef="2" joinDate="2024-03-10"/>
\end{lstlisting}

Az \texttt{HasMembership} elemek az Athlete és Membership entitások közötti 1--N kapcsolatot írják le. 
Az \texttt{athleteRef} és \texttt{membershipRef} attribútumok az érintett sportoló és tagság elsődleges kulcsaira hivatkoznak, 
míg a \texttt{joinDate} a belépés dátumát tárolja.

\subsection*{Példa N--M kapcsolat XML-es ábrázolására (Athlete–TrainingGroup)}

\begin{lstlisting}[language=MyXML, caption={JoinGroup kapcsolat (Athlete–TrainingGroup)}]
<JoinGroup joinGroupID="1" athleteRef="1" groupRef="1"/>
<JoinGroup joinGroupID="2" athleteRef="1" groupRef="2"/>
<JoinGroup joinGroupID="3" athleteRef="2" groupRef="1"/>
<JoinGroup joinGroupID="4" athleteRef="3" groupRef="2"/>
\end{lstlisting}

A \texttt{JoinGroup} kapcsolat-elem az Athlete és TrainingGroup közötti N--M kapcsolatot modellezi. 
Az \texttt{athleteRef} és \texttt{groupRef} attribútumok az Athlete és TrainingGroup entitások azonosítóira mutatnak, 
így egy XML „kapcsolótáblát” kapunk, amelyben ugyanaz a sportoló több csoportban is szerepelhet, és egy csoporthoz több sportoló is tartozhat.

\clearpage

\section{Az XML dokumentum alapján XMLSchema készítése}

Az XSD séma a sportegyesület XML-adatmodelljének formális leírását adja, amely biztosítja az adatok szerkezetének, 
adattípusainak és kapcsolatainak érvényességét. Az egyszerű típusok (például \texttt{idType}, \texttt{moneyType}, 
\texttt{timeHMType}, \texttt{placementType}) segítségével biztosított az azonosítók, pénzösszegek, időformátumok 
és helyezések tartományellenőrzése. Ezekre épülnek a közös komplex típusok (\texttt{NameType}, \texttt{ContactsType}, 
\texttt{ProfileType}, \texttt{ScheduleType}), valamint az egyes entitástípusok (\texttt{AthleteType}, 
\texttt{MembershipType}, \texttt{CoachType}, \texttt{LocationType}, \texttt{TrainingGroupType}, \texttt{CompetitionType}).  
A kapcsolatokhoz külön komplex típusok készültek (\texttt{HasMembershipType}, \texttt{JoinGroupType}, \texttt{LeadGroupType}, 
\texttt{TakePlaceAtType}, \texttt{CompeteInType}), amelyek attribútumként tárolják az érintett entitások azonosítóira mutató 
hivatkozásokat. A \texttt{Sport\_Club\_VTJ4ES} gyökérelem alatt globális elemek sorozata jelenik meg, és 
\texttt{xs:key} / \texttt{xs:keyref} segítségével kerültek definiálásra az elsődleges kulcsok és idegen kulcsok, 
míg \texttt{xs:unique} elemek további egyediségi megszorításokat valósítanak meg.

\subsection*{Példa entitás XSD-leképezésére (AthleteType)}

\begin{lstlisting}[language=MyXML, caption={AthleteType komplex típus XSD-ben}]
<xs:simpleType name="idType">
    <xs:restriction base="xs:integer">
        <xs:minInclusive value="1"/>
    </xs:restriction>
</xs:simpleType>

<xs:complexType name="NameType">
    <xs:sequence>
        <xs:element name="first_name" type="xs:string"/>
        <xs:element name="last_name" type="xs:string"/>
    </xs:sequence>
</xs:complexType>

<xs:complexType name="AthleteType">
    <xs:sequence>
        <xs:element name="name" type="NameType"/>
        <xs:element name="birth_date" type="xs:string"/>
        <xs:element name="contacts" type="ContactsType"/>
        <xs:element name="skills" type="xs:string" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="athleteID" type="idType" use="required"/>
</xs:complexType>

<xs:element name="Athlete" type="AthleteType"/>
\end{lstlisting}

Az \texttt{idType} egyszerű típus biztosítja, hogy az azonosítók mindig 1-nél nagyobb egész számok legyenek. 
Az \texttt{AthleteType} komplex típus írja le a sportoló entitást: a gyermekelemek között szerepel a név, 
születési dátum, elérhetőségek és a többértékű \texttt{skills} elem (maxOccurs=\texttt{"unbounded"}). 
Az \texttt{athleteID} attribútum az entitás elsődleges kulcsát reprezentálja, míg a globális \texttt{Athlete} elem 
az XML-ben ténylegesen megjelenő elemtípust adja.

\subsection*{Kapcsolattípus és kulcsok XSD-ben (HasMembership, key, keyref, unique)}

\begin{lstlisting}[language=MyXML, caption={Kapcsolatok és kulcsok XSD-ben}]
<xs:complexType name="HasMembershipType">
    <xs:attribute name="hasMembershipID" type="idType" use="required"/>
    <xs:attribute name="athleteRef" type="idType" use="required"/>
    <xs:attribute name="membershipRef" type="idType" use="required"/>
    <xs:attribute name="joinDate" type="xs:string" use="required"/>
</xs:complexType>

<xs:key name="athlete_key">
    <xs:selector xpath="Athlete"/>
    <xs:field xpath="@athleteID"/>
</xs:key>

<xs:key name="membership_key">
    <xs:selector xpath="Membership"/>
    <xs:field xpath="@membershipID"/>
</xs:key>

<xs:keyref name="hasMembership_athlete_fk" refer="athlete_key">
    <xs:selector xpath="HasMembership"/>
    <xs:field xpath="@athleteRef"/>
</xs:keyref>

<xs:keyref name="hasMembership_membership_fk" refer="membership_key">
    <xs:selector xpath="HasMembership"/>
    <xs:field xpath="@membershipRef"/>
</xs:keyref>

<xs:unique name="oneCoachPerGroup">
    <xs:selector xpath="LeadGroup"/>
    <xs:field xpath="@groupRef"/>
</xs:unique>

<xs:unique name="oneLocationPerGroup">
    <xs:selector xpath="TakePlaceAt"/>
    <xs:field xpath="@groupRef"/>
</xs:unique>
\end{lstlisting}

A \texttt{HasMembershipType} kapcsolat-típust modellez az Athlete és Membership entitások között, 
ahol az \texttt{athleteRef} és \texttt{membershipRef} attribútumok idegen kulcsként működnek. 
Az \texttt{xs:key} elemek az Athlete és Membership elsődleges kulcsait definiálják, 
míg az \texttt{xs:keyref} gondoskodik arról, hogy a hivatkozott azonosítók valóban létező entitásokra mutassanak. 
Az \texttt{xs:unique} elemek további üzleti szabályokat valósítanak meg, például azt, hogy egy csoporthoz legfeljebb 
egy edző (\texttt{LeadGroup}) vagy egy helyszín (\texttt{TakePlaceAt}) tartozhat.

\chapter{II. feladat – DOM alapú feldolgozás}

\section{DOM tervezése és általános működés}

A DOM (Document Object Model) alapú megoldás célja, hogy a korábban megtervezett XML adatmodellt
Java kódból kényelmesen lehessen bejárni, módosítani és kiírni. A DOM lényege, hogy a
\texttt{Sport\_Club\_VTJ4ES.xml} dokumentum teljes tartalmát egy fa struktúraként betölti a memóriába:
minden XML elemhez, attribútumhoz és szöveghez külön \texttt{Node} (illetve \texttt{Element}) objektum tartozik.
Így a program a fa tetszőleges pontján szabadon tud:

\begin{itemize}
  \item elemeket keresni (pl. \texttt{getElementsByTagName("Athlete")}),
  \item attribútumokat és szöveges tartalmakat kiolvasni vagy módosítani,
  \item új elemeket beszúrni vagy meglévőket törölni,
  \item a módosított DOM-fát új XML dokumentumként kiírni.
\end{itemize}

A DOM megközelítés előnye, hogy a teljes dokumentum egyszerre, strukturáltan elérhető, ezért ideális
összetett lekérdezésekhez és többlépéses módosításokhoz. Hátránya, hogy nagyobb XML állomány esetén
jelentős memóriát foglal. A gyakorlatban ez a feladat méreténél nem okoz gondot, viszont jól szemlélteti
a fa alapú feldolgozás lépéseit.

\bigskip

A DOM megvalósítás négy fő Java osztályra épül:
\begin{itemize}
  \item \texttt{VTJ4ESDomRead}: az XML beolvasása és bejárása,
  \item \texttt{VTJ4ESDomQuery}: lekérdezések futtatása a DOM-fán,
  \item \texttt{VTJ4ESDomWrite}: a DOM-fa kiírása formázott XML-be,
  \item \texttt{VTJ4ESDomModify}: az XML-tartalom módosítása DOM-on keresztül.
\end{itemize}

\section{VTJ4ESDomRead – Adatolvasás DOM-mal}

A \texttt{VTJ4ESDomRead} osztály egy DOM-alapú XML-olvasó program, amely a teljes XML dokumentumot 
memóriába tölti, majd külön metódusokkal (\texttt{readAthletes}, \texttt{readMemberships}, 
\texttt{readCoaches}, \texttt{readLocations}, \texttt{readTrainingGroups}, \texttt{readCompetitions}) 
kiolvassa az egyes entitások adatait és strukturált formában a konzolra írja.

\subsection*{DOM parser inicializálása}

\begin{lstlisting}[language=MyJava, caption={DOM parser létrehozása és dokumentum betöltése}]
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
factory.setIgnoringElementContentWhitespace(true);
DocumentBuilder builder = factory.newDocumentBuilder();

Document document = builder.parse(new File("../VTJ4ES_XML.xml"));
document.getDocumentElement().normalize();
\end{lstlisting}

\subsection*{Athlete elemek feldolgozása}

\begin{lstlisting}[language=MyJava, caption={Athlete elemek bejárása VTJ4ESDomRead-ban}]
NodeList athleteList = document.getElementsByTagName("Athlete");
for (int i = 0; i < athleteList.getLength(); i++) {
    Node node = athleteList.item(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        Element e = (Element) node;

        String athleteId = e.getAttribute("athleteID");

        Element nameElem = (Element) e.getElementsByTagName("name").item(0);
        String firstName = nameElem.getElementsByTagName("first_name")
                                   .item(0).getTextContent();
        String lastName = nameElem.getElementsByTagName("last_name")
                                  .item(0).getTextContent();
    }
}
\end{lstlisting}

\subsection*{Többértékű skills elemek kezelése}

\begin{lstlisting}[language=MyJava, caption={Többértékű skills elemek kezelése}]
NodeList skills = e.getElementsByTagName("skills");
for (int j = 0; j < skills.getLength(); j++) {
    String skill = skills.item(j).getTextContent();
    // kiiras vagy tovabbfeldolgozas
}
\end{lstlisting}

\section{VTJ4ESDomQuery – Adatlekérdezés DOM-mal}

A \texttt{VTJ4ESDomQuery} osztály DOM-alapú lekérdezéseket valósít meg: 
szűri a sportolókat bizonyos skillek alapján, megkeresi például a legnagyobb kapacitású 
helyszínt, vagy lekérdezi a 2000 után született sportolókat. Az eredményeket 
\texttt{StringBuilder} segítségével XML-szerű kimenetté állítja össze.

\subsection*{Sportolók szűrése skill alapján}

\begin{lstlisting}[language=MyJava, caption={Sportolók szűrése skill alapján}]
NodeList athleteList = doc.getElementsByTagName("Athlete");
for (int i = 0; i < athleteList.getLength(); i++) {
    Node node = athleteList.item(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        Element athlete = (Element) node;

        NodeList skills = athlete.getElementsByTagName("skills");
        boolean hasSpeed = false;
        for (int j = 0; j < skills.getLength(); j++) {
            String skillValue = skills.item(j).getTextContent();
            if ("speed".equalsIgnoreCase(skillValue)) {
                hasSpeed = true;
                break;
            }
        }

        if (hasSpeed) {
            String athleteId = athlete.getAttribute("athleteID");
            // eredmeny osszegyujtese StringBuilder-be
        }
    }
}
\end{lstlisting}

\subsection*{Legnagyobb kapacitású Location kiválasztása}

\begin{lstlisting}[language=MyJava, caption={Legnagyobb kapacitású helyszín (Location) kiválasztása}]
NodeList locationList = doc.getElementsByTagName("Location");
int maxCapacity = -1;
Element maxLocation = null;

for (int i = 0; i < locationList.getLength(); i++) {
    Node node = locationList.item(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        Element location = (Element) node;
        String capacityText = location.getElementsByTagName("capacity")
                                      .item(0).getTextContent();
        int capacity = 0;
        try {
            capacity = Integer.parseInt(capacityText.trim());
        } catch (NumberFormatException e) {
            // ervenytelen ertek figyelmen kivul hagyasa
        }

        if (capacity > maxCapacity) {
            maxCapacity = capacity;
            maxLocation = location;
        }
    }
}
\end{lstlisting}

\section{VTJ4ESDomWrite – Adatírás DOM-ból XML-be}

A \texttt{VTJ4ESDomWrite} osztály a memóriában lévő DOM fát írja ki formázott XML dokumentumba. 
A \texttt{Transformer} API segítségével gondoskodik az olvasható, behúzásokkal ellátott kimenetről, 
mind a konzolra, mind fájlba.

\begin{lstlisting}[language=MyJava, caption={DOM dokumentum kiírása a konzolra}]
TransformerFactory transformerFactory = TransformerFactory.newInstance();
Transformer transformer = transformerFactory.newTransformer();

transformer.setOutputProperty(OutputKeys.INDENT, "yes");
transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");

DOMSource source = new DOMSource(doc);
StreamResult consoleResult = new StreamResult(System.out);
transformer.transform(source, consoleResult);
\end{lstlisting}

\begin{lstlisting}[language=MyJava, caption={DOM dokumentum fájlba írása}]
private static void writeDocumentToFile(Document doc, String filename)
        throws TransformerException {
    TransformerFactory transformerFactory = TransformerFactory.newInstance();
    Transformer transformer = transformerFactory.newTransformer();

    transformer.setOutputProperty(OutputKeys.INDENT, "yes");
    transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
    transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");

    DOMSource source = new DOMSource(doc);
    StreamResult result = new StreamResult(new File(filename));
    transformer.transform(source, result);
}
\end{lstlisting}

\section{VTJ4ESDomModify – Adatmódosítás DOM-mal}

A \texttt{VTJ4ESDomModify} osztály a beolvasott DOM-fát módosítja: például előtagot fűz az 
\texttt{athleteID} értékekhez, módosítja a tagsági díjakat, minimális kapacitást állít be a 
helyszíneknél, illetve jelölést ad a \texttt{profile\_text} végére. A módosítások után 
a frissített dokumentum formázott XML-ként kerül kiírásra.

\subsection*{Módosítások végrehajtása és kiírása}

\begin{lstlisting}[language=MyJava, caption={Módosítások végrehajtása és kiírása}]
Document doc = dBuilder.parse(xmlFile);
doc.getDocumentElement().normalize();

modifyAthletes(doc);
modifyMemberships(doc);
modifyLocations(doc);

TransformerFactory transformerFactory = TransformerFactory.newInstance();
Transformer transformer = transformerFactory.newTransformer();

transformer.setOutputProperty(OutputKeys.INDENT, "yes");
transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");

DOMSource source = new DOMSource(doc);
StreamResult consoleResult = new StreamResult(System.out);
transformer.transform(source, consoleResult);
\end{lstlisting}

\subsection*{Athlete azonosítók módosítása}

\begin{lstlisting}[language=MyJava, caption={Athlete ID-k módosítása VTJ4ESDomModify-ban}]
private static void modifyAthletes(Document doc) {
    NodeList athleteList = doc.getElementsByTagName("Athlete");

    for (int i = 0; i < athleteList.getLength(); i++) {
        Node node = athleteList.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            Element athlete = (Element) node;
            String id = athlete.getAttribute("athleteID");

            if (id != null && !id.startsWith("ATH_")) {
                athlete.setAttribute("athleteID", "ATH_" + id);
            }
        }
    }
}
\end{lstlisting}

\subsection*{Location kapacitások és profil szöveg módosítása}

\begin{lstlisting}[language=MyJava, caption={Location elemek módosítása VTJ4ESDomModify-ban}]
private static void modifyLocations(Document doc) {
    NodeList locationList = doc.getElementsByTagName("Location");

    for (int i = 0; i < locationList.getLength(); i++) {
        Node node = locationList.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            Element location = (Element) node;

            Node capacityNode = location.getElementsByTagName("capacity").item(0);
            if (capacityNode != null && capacityNode.getNodeType() == Node.ELEMENT_NODE) {
                String capacityText = capacityNode.getTextContent().trim();
                try {
                    int capacity = Integer.parseInt(capacityText);
                    if (capacity < 100) {
                        capacity = 100;
                    }
                    capacityNode.setTextContent(String.valueOf(capacity));
                } catch (NumberFormatException e) {
                    // ervenytelen ertek figyelmen kivul hagyasa
                }
            }

            NodeList profileList = location.getElementsByTagName("profile");
            if (profileList.getLength() > 0) {
                Element profile = (Element) profileList.item(0);
                Node profileTextNode = profile.getElementsByTagName("profile_text")
                                              .item(0);
                if (profileTextNode != null
                        && profileTextNode.getNodeType() == Node.ELEMENT_NODE) {
                    String oldText = profileTextNode.getTextContent();
                    if (!oldText.endsWith(" (updated)")) {
                        profileTextNode.setTextContent(oldText + " (updated)");
                    }
                }
            }
        }
    }
}
\end{lstlisting}

\end{document}
